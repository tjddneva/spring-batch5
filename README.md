* [실무를 위한 Spring Batch의 모든 것 : 성능 개선부터 프로젝트까지](https://fastcampus.co.kr/dev_online_springbatch) 강의 자료

## Docker Set Up

```bash
$ cd spring-batch5
$ docker-compose up -d 
```

### MySQL

#### Connection

* url: jdbc:mysql://localhost:3306/spring_batch
* username: root
* password:

#### SQL Log

```mysql
show variables like 'general_log%'; # general_log 획인
set global general_log = 'ON'; # `OFF` 경우 `ON` 으로 변경
```

| Variable\_name     | Value                           |
|:-------------------|:--------------------------------|
| general\_log       | ON                              |
| general\_log\_file | /var/lib/mysql/24b6ff2d48b4.log |

`general\_log\_file`에 SQL log 파일 생성

```bash                               
$ tail -f volumes/mysql/default/24b6ff2d48b4.log # sql 로그 확인 
$ tail -f volumes/mysql/default/24b6ff2d48b4.log | grep "select" # select 포함된 내용만 필터링  
```

#### Sample Data Set up

```mysql
# 1-4 ItemReader - JPA 페이징 처리 sample data
INSERT INTO payment_source (discount_amount, final_amount, original_amount, partner_corp_name, payment_date)
VALUES (100.00, 900.00, 1000.00, 'Partner Corp 1', '2025-05-01'),
       (150.00, 1850.00, 2000.00, 'Partner Corp 2', '2025-05-01'),
       (200.00, 2800.00, 3000.00, 'Partner Corp 3', '2025-05-01'),
       (250.00, 3750.00, 4000.00, 'Partner Corp 4', '2025-05-01'),
       (300.00, 4700.00, 5000.00, 'Partner Corp 5', '2025-05-01'),
       (350.00, 5650.00, 6000.00, 'Partner Corp 6', '2025-05-01'),
       (400.00, 6600.00, 7000.00, 'Partner Corp 7', '2025-05-01'),
       (450.00, 7550.00, 8000.00, 'Partner Corp 8', '2025-05-01'),
       (500.00, 8500.00, 9000.00, 'Partner Corp 9', '2025-05-01'),
       (550.00, 9450.00, 10000.00, 'Partner Corp 10', '2025-05-01'),
       (600.00, 10400.00, 11000.00, 'Partner Corp 11', '2025-05-01'),
       (650.00, 11350.00, 12000.00, 'Partner Corp 12', '2025-05-01'),
       (700.00, 12300.00, 13000.00, 'Partner Corp 13', '2025-05-01'),
       (750.00, 13250.00, 14000.00, 'Partner Corp 14', '2025-05-01'),
       (800.00, 14200.00, 15000.00, 'Partner Corp 15', '2025-05-01'),
       (850.00, 15150.00, 16000.00, 'Partner Corp 16', '2025-05-01'),
       (900.00, 16100.00, 17000.00, 'Partner Corp 17', '2025-05-01'),
       (950.00, 17050.00, 18000.00, 'Partner Corp 18', '2025-05-01'),
       (1000.00, 18000.00, 19000.00, 'Partner Corp 19', '2025-05-01'),
       (1050.00, 18950.00, 20000.00, 'Partner Corp 20', '2025-05-01')
;

INSERT INTO payment_source (discount_amount, final_amount, original_amount, partner_corp_name, payment_date)
VALUES (100.00, 900.00, 1000.00, 'Partner Corp 1', '2025-05-02'),
       (150.00, 1850.00, 2000.00, 'Partner Corp 2', '2025-05-02'),
       (200.00, 2800.00, 3000.00, 'Partner Corp 3', '2025-05-02'),
       (250.00, 3750.00, 4000.00, 'Partner Corp 4', '2025-05-02'),
       (300.00, 4700.00, 5000.00, 'Partner Corp 5', '2025-05-02'),
       (350.00, 5650.00, 6000.00, 'Partner Corp 6', '2025-05-02'),
       (400.00, 6600.00, 7000.00, 'Partner Corp 7', '2025-05-02'),
       (450.00, 7550.00, 8000.00, 'Partner Corp 8', '2025-05-02'),
       (500.00, 8500.00, 9000.00, 'Partner Corp 9', '2025-05-02'),
       (550.00, 9450.00, 10000.00, 'Partner Corp 10', '2025-05-02'),
       (600.00, 10400.00, 11000.00, 'Partner Corp 11', '2025-05-02'),
       (650.00, 11350.00, 12000.00, 'Partner Corp 12', '2025-05-02'),
       (700.00, 12300.00, 13000.00, 'Partner Corp 13', '2025-05-02'),
       (750.00, 13250.00, 14000.00, 'Partner Corp 14', '2025-05-02'),
       (800.00, 14200.00, 15000.00, 'Partner Corp 15', '2025-05-02'),
       (850.00, 15150.00, 16000.00, 'Partner Corp 16', '2025-05-02'),
       (900.00, 16100.00, 17000.00, 'Partner Corp 17', '2025-05-02'),
       (950.00, 17050.00, 18000.00, 'Partner Corp 18', '2025-05-02'),
       (1000.00, 18000.00, 19000.00, 'Partner Corp 19', '2025-05-02'),
       (1050.00, 18950.00, 20000.00, 'Partner Corp 20', '2025-05-02')
;
```

## Spring Batch Schema

### DDL

```mysql
-- Autogenerated: do not edit this file
CREATE TABLE BATCH_JOB_INSTANCE
(
    JOB_INSTANCE_ID BIGINT       NOT NULL PRIMARY KEY,
    VERSION         BIGINT,
    JOB_NAME        VARCHAR(100) NOT NULL,
    JOB_KEY         VARCHAR(32)  NOT NULL,
    constraint JOB_INST_UN unique (JOB_NAME, JOB_KEY)
) ENGINE = InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION
(
    JOB_EXECUTION_ID BIGINT      NOT NULL PRIMARY KEY,
    VERSION          BIGINT,
    JOB_INSTANCE_ID  BIGINT      NOT NULL,
    CREATE_TIME      DATETIME(6) NOT NULL,
    START_TIME       DATETIME(6) DEFAULT NULL,
    END_TIME         DATETIME(6) DEFAULT NULL,
    STATUS           VARCHAR(10),
    EXIT_CODE        VARCHAR(2500),
    EXIT_MESSAGE     VARCHAR(2500),
    LAST_UPDATED     DATETIME(6),
    constraint JOB_INST_EXEC_FK foreign key (JOB_INSTANCE_ID)
        references BATCH_JOB_INSTANCE (JOB_INSTANCE_ID)
) ENGINE = InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION_PARAMS
(
    JOB_EXECUTION_ID BIGINT       NOT NULL,
    PARAMETER_NAME   VARCHAR(100) NOT NULL,
    PARAMETER_TYPE   VARCHAR(100) NOT NULL,
    PARAMETER_VALUE  VARCHAR(2500),
    IDENTIFYING      CHAR(1)      NOT NULL,
    constraint JOB_EXEC_PARAMS_FK foreign key (JOB_EXECUTION_ID)
        references BATCH_JOB_EXECUTION (JOB_EXECUTION_ID)
) ENGINE = InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION
(
    STEP_EXECUTION_ID  BIGINT       NOT NULL PRIMARY KEY,
    VERSION            BIGINT       NOT NULL,
    STEP_NAME          VARCHAR(100) NOT NULL,
    JOB_EXECUTION_ID   BIGINT       NOT NULL,
    CREATE_TIME        DATETIME(6)  NOT NULL,
    START_TIME         DATETIME(6) DEFAULT NULL,
    END_TIME           DATETIME(6) DEFAULT NULL,
    STATUS             VARCHAR(10),
    COMMIT_COUNT       BIGINT,
    READ_COUNT         BIGINT,
    FILTER_COUNT       BIGINT,
    WRITE_COUNT        BIGINT,
    READ_SKIP_COUNT    BIGINT,
    WRITE_SKIP_COUNT   BIGINT,
    PROCESS_SKIP_COUNT BIGINT,
    ROLLBACK_COUNT     BIGINT,
    EXIT_CODE          VARCHAR(2500),
    EXIT_MESSAGE       VARCHAR(2500),
    LAST_UPDATED       DATETIME(6),
    constraint JOB_EXEC_STEP_FK foreign key (JOB_EXECUTION_ID)
        references BATCH_JOB_EXECUTION (JOB_EXECUTION_ID)
) ENGINE = InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION_CONTEXT
(
    STEP_EXECUTION_ID  BIGINT        NOT NULL PRIMARY KEY,
    SHORT_CONTEXT      VARCHAR(2500) NOT NULL,
    SERIALIZED_CONTEXT TEXT,
    constraint STEP_EXEC_CTX_FK foreign key (STEP_EXECUTION_ID)
        references BATCH_STEP_EXECUTION (STEP_EXECUTION_ID)
) ENGINE = InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION_CONTEXT
(
    JOB_EXECUTION_ID   BIGINT        NOT NULL PRIMARY KEY,
    SHORT_CONTEXT      VARCHAR(2500) NOT NULL,
    SERIALIZED_CONTEXT TEXT,
    constraint JOB_EXEC_CTX_FK foreign key (JOB_EXECUTION_ID)
        references BATCH_JOB_EXECUTION (JOB_EXECUTION_ID)
) ENGINE = InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION_SEQ
(
    ID         BIGINT  NOT NULL,
    UNIQUE_KEY CHAR(1) NOT NULL,
    constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
) ENGINE = InnoDB;

INSERT INTO BATCH_STEP_EXECUTION_SEQ (ID, UNIQUE_KEY)
select *
from (select 0 as ID, '0' as UNIQUE_KEY) as tmp
where not exists(select * from BATCH_STEP_EXECUTION_SEQ);

CREATE TABLE BATCH_JOB_EXECUTION_SEQ
(
    ID         BIGINT  NOT NULL,
    UNIQUE_KEY CHAR(1) NOT NULL,
    constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
) ENGINE = InnoDB;

INSERT INTO BATCH_JOB_EXECUTION_SEQ (ID, UNIQUE_KEY)
select *
from (select 0 as ID, '0' as UNIQUE_KEY) as tmp
where not exists(select * from BATCH_JOB_EXECUTION_SEQ);

CREATE TABLE BATCH_JOB_SEQ
(
    ID         BIGINT  NOT NULL,
    UNIQUE_KEY CHAR(1) NOT NULL,
    constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
) ENGINE = InnoDB;

INSERT INTO BATCH_JOB_SEQ (ID, UNIQUE_KEY)
select *
from (select 0 as ID, '0' as UNIQUE_KEY) as tmp
where not exists(select * from BATCH_JOB_SEQ);

```

### drop table

```mysql
DROP TABLE IF EXISTS BATCH_STEP_EXECUTION_CONTEXT;
DROP TABLE IF EXISTS BATCH_JOB_EXECUTION_CONTEXT;
DROP TABLE IF EXISTS BATCH_STEP_EXECUTION;
DROP TABLE IF EXISTS BATCH_JOB_EXECUTION_PARAMS;
DROP TABLE IF EXISTS BATCH_JOB_EXECUTION;
DROP TABLE IF EXISTS BATCH_JOB_INSTANCE;

DROP TABLE IF EXISTS BATCH_STEP_EXECUTION_SEQ;
DROP TABLE IF EXISTS BATCH_JOB_EXECUTION_SEQ;
DROP TABLE IF EXISTS BATCH_JOB_SEQ;
```

### Meta Table Select Query

```mysql

SELECT ji.JOB_INSTANCE_ID,
       ji.JOB_KEY,
       ji.JOB_NAME,
       je.JOB_EXECUTION_ID,
       jep.PARAMETER_NAME,
       jep.PARAMETER_NAME,
       jep.PARAMETER_VALUE,
       jec.SHORT_CONTEXT,
       se.STEP_EXECUTION_ID,
       sec.SHORT_CONTEXT AS STEP_EXECUTION_CONTEXT
FROM BATCH_JOB_INSTANCE ji
         INNER JOIN BATCH_JOB_EXECUTION je
                    ON ji.JOB_INSTANCE_ID = je.JOB_INSTANCE_ID
         LEFT JOIN BATCH_JOB_EXECUTION_PARAMS jep
                   ON je.JOB_EXECUTION_ID = jep.JOB_EXECUTION_ID
         LEFT JOIN BATCH_JOB_EXECUTION_CONTEXT jec
                   ON je.JOB_EXECUTION_ID = jec.JOB_EXECUTION_ID
         LEFT JOIN BATCH_STEP_EXECUTION se
                   ON je.JOB_EXECUTION_ID = se.JOB_EXECUTION_ID
         LEFT JOIN BATCH_STEP_EXECUTION_CONTEXT sec
                   ON se.STEP_EXECUTION_ID = sec.STEP_EXECUTION_ID

where je.JOB_INSTANCE_ID = 12
;
```

## 예제 코드

* Part 1. Spring Batch 기초
  * 1-1
    * Ch 3. 첫 배치 Job 구현 1
    * Ch 4. 첫 배치 Job 구현 2
  * 1-2
    * Ch 4. Job 핵심 요소, 한 번에 실습하며 이해하기
  * 1-3
    * Ch 4. JobInstance와 JobParameter – 중복방지와 실행구조의 이해
    * Ch 4. Step Tasklet 실습 - 단일 작업 Step 구현하기
    * Ch 4. Step Chunk 실습 - 반복 처리 Step 구현하기
  * 1-4
    * Ch 5. Chunk 처리 개념 - Chunk 처리 방식의 개념 및 장점
    * Ch 5. ItemReader - JPA 페이징 처리
    * Ch 5. ItemProcessor - 데이터 변환 처리
    * Ch 5. ItemWriter - JPA Writer 처리
  * 1-5
    * Ch 6. 예외 처리 전략 skip 실습 - 1
    * Ch 6. 예외 처리 전략 skip 실습 - 2
  * 1-6
    * Ch 6. 예외 처리 전략 retry 실습 - 1
    * Ch 6. 예외 처리 전략 retry 실습 - 2
  * 1-7
    * Ch 6. JobExecutionListener Job 실행 전후 이벤트 처리
    * Ch 6. StepExecutionListener: Step 실행 전후 이벤트 처리
    * Ch 6. ChunkListener: 다양한 Chunk 리스너 살펴보기
* Part 2. Spring Batch 성능 최적화 기법
  * 2-1
    * Ch 1. 성능 분석 및 측정의 기본 개념과 접근 방법 개요
    * Ch 1. 스프링 배치 Reader 성능 개선 limit offset 방식의 한계 1
  * 2-2
    * Ch 1. 스프링 배치 Reader 성능 개선 No Offset 방식 1
    * Ch 1. 스프링 배치 Reader 성능 개선 No Offset 방식 2
    * Ch 1. 스프링 배치 Reader 성능 개선 No Offset 방식 3
  * 2-3
    * Ch 1. 스프링 배치 Reader 성능 개선 Cursor를 통한 Steaming 1
    * Ch 1. 스프링 배치 Reader 성능 개선 Cursor를 통한 Steaming 2
    * Ch 1. 스프링 배치 Reader 성능 개선 Cursor를 통한 Steaming 3
  * 2-4
    * Ch 2. 스프링 배치 Processor & Writer 성능 개선 개요 및 데이터 셋업
  * 2-5
    * Ch 2. 스프링 배치 Processor 성능 개선
  * 2-6
    * Ch 2. 스프링 배치 Writer 성능 개선
  * 2-7
    * Ch 3. 스프링 배치 성능 개선: Partition Step
* Part 3.